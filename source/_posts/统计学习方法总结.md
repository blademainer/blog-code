---
title: 统计学习方法总结
comments: true
mathjax: true
categories: 机器学习
tags:
  - 机器学习
  - 统计学习方法
  - 概率论
  - SVM
  - 过拟合
  - 朴素贝叶斯
abbrlink: 9710
date: 2017-09-23 19:47:38
---

<center>{% asset_img cover.jpg machine learning%}</center>

本文主要研究监督学习，所谓的监督学习就是在给定的，有限的，用于学习的训练数据集合（training data）出发，假设数据是独立同分布产生的；并且假设要学习的模型属于某个集合，即**假设空间**；我们根据一定的评价准则，从假设空间中选取一个最优的模型，使它对已知的训练数据以及未知的测试数据在给定评价准则下有最优的预测，最优模型的选取由**算法**实现。
所以统计学习方法有三个要素：**模型**、**策略**、**算法**。

<!--more-->

## 统计学习
- 监督学习
- 半监督学习
- 无监督学习
- 强化学习





## 输入空间、特征空间与输出空间

1. 输入变量&输出变量均连续-> 回归问题
2. 输出空间为有限个离散变量的预测问题-> 分类问题
3. 输入与输出均为变量序列的预测问题-> 标注问题


## 风险函数

- 期望风险：模型关于联合分布的期望损失
- 经验风险：模型关于训练样本的平均损失
按照大数定律，当样本数据量区域无穷时，经验风险趋近于期望风险；
但是当样本容量很小时，经验风险的效果就不会太好，此时容易出现过拟合现象。
此时，结构风险就被提出。结构风险是在经验风险的基础上添加上表示模型复杂度的正则化项/罚项。
极大似然估计是经验风险最小化的一个特例。
最大后验概率估计是结构风险最小化的一个特例；


## 模型
监督学习里要学习的模型就是**决策函数或者条件概率分布**。

此时不得不提到生成方法以及判别方法。

- 生成方法，由数据学习联合概率分布$P(X,Y)$，然后求出条件概率分布模型，即生成模型：
$$
P(Y|X)=\frac{P(X,Y)}{P(X)}
$$
- 判别方法是由数据直接学习决策函数或者条件概率分布作为预测模型，即判别模型。

### 生成模型与判别模型


- 生成模型常见的主要有：
1. 高斯混合模型
2. 朴素贝叶斯
3. 混合高斯模型GMM
4. 隐马尔可夫模型HMM
5. 马尔可夫的随机场
6. KNN


- 常见的判别模型有：
1. 支持向量机
2. 传统的神经网络
3. 线性判别分析
4. 线性回归
5. 条件随机场
6. 最大熵模型
7. 逻辑斯特回归



![](https://uploadfiles.nowcoder.com/images/20170902/1124449_1504333555806_99A61EED5E6F79CC20E4E8CFDA6B5AF4)


## 策略
指定策略的目的就是为了挑选出假设空间中到底哪个模型才是我们真正需要的。此时会用到损失函数以及风险函数的概念。

- 0-1 损失函数
$$
L(Y,f(X))=\left\{\begin{aligned}
1,    && Y \neq f(X)\\
0,    &&Y = f(X) 
\end{aligned}\right.
$$

- 平法损失函数
$$
L(Y,f(X))=(Y-f(X)^2
$$

- 绝对值损失函数

$$
L(Y,f(X))=|Y-f(X)|
$$

- 对数损失函数
$$
L(Y,P(Y|X))=-logP(Y|X)
$$

损失函数越小的话代表模型越好。$(X,Y)$是随机变量符合联合分布概率$P(X,Y)$，所以损失函数的期望被定义为：
$$
R_{ref}(f)=E_p[L(Y,f(X))]=\int_{\mathcal{X} \times \mathcal{Y}}L(y,f(x))P(x,y)dxdy
$$
以上是模型$f(X)$关于联合分布$P(X,Y)$的平均意义下的损失，称为风险函数或者**期望损失**（expected loss）。
但是呢，期望损失不易求解，我们一般用**模型关于训练数据集的平均损失**来逼近期望损失，即：
$$
R_{emp}(f)=E_p[L(Y,f(X))]=\frac{1}{N} \sum_{i=1}^NL(y_i,f(x_i))
$$
**经验风险最小化**的策略认为，经验风险最小的模型就是最优的模型，于是按照这种定义，我们有：
$$
f^*={argmin}_{f \in \mathcal{F} } R_{emp}
$$
其中的$\mathcal{F}$是假设空间。
最大似然估计就是经验风险最小化的一个例子：当模型为条件概率，损失函数是对数损失时，经验风险最小化就等价于极大似然估计。
根据大数定理可知，当样本容量N趋近于无限时，经验风险趋近于期望风险。但是如果样本数量是有限时，此时会出现过拟合现象，那么这时候需要结构风险的帮助。
结构风险是为了防止过拟合而提出的策略，结构风险最小化等价于正则化（regularization）。其定义是
$$
R_{srm}(f)=\frac{1}{N} \sum_{i=1}^NL(y_i,f(x_i))+\lambda J(f)
$$
其中的$J(f)$是衡量模型复杂度的项，也叫罚项。当模型越复杂时，$J(f)$越大；模型越简单时，$J(f)$越小。 
最大后验概率估计（MAP）就是结构风险最小化的一个例子：当模型时条件概率，损失函数是对数损失函数，模型复杂度由先验概率表示时，结构风险最小化就等价于MAP。

监督学习的模型可以分为概率模型与非概率模型，由条件概率分布$P(Y|X)$或者决策函数$Y=f(X)$表示。

## 算法
算法是指学习模型的具体计算方法： **find global optimization solution efficiently**.

## 模型选择

**模型选择的主要方式有：正则化与交叉验证**。

在经验风险最小化时已经了解到正则化的由来，正则化就是针对过拟合现象提出的解决策略。

**过拟合**是指学习模型时选择的模型包含的参数过多，以致于这一模型对已知数据的预测很好，而对未知数据的预测能力变得很差。 以下介绍两种正则化的范数：$L_1$ and $L_2$

### 正则化
#### L2范数正则

$$
C=C_0+ \frac{\alpha}{2n}\sum_ww^2

$$

对$w$以及$b$求导如下：
$$
 \frac{\partial C}{\partial w}= \frac{\partial C_0}{\partial w}+\frac{\lambda}{n}w
 
 \frac{\partial C}{\partial b}= \frac{\partial C_0}{\partial b}
 
$$

由梯度下降法可知：

$$
w \rightarrow w-\eta\frac{\partial C}{\partial w}=\left(1-\frac{\eta\lambda}{n} \right)w-\eta\frac{\partial C_0}{\partial w}

$$

系数$\left(1-\frac{\eta\lambda}{n} \right)$是小于1的，相比于原来的系数等于一，此时的效果相当于就是权值衰减（weight decay）。


注意到**过拟合**的时候，我们的假设函数要顾及到每一个数据点，模型就会尝试对所有数据点进行拟合，包括一些异常点；此时形成的拟合函数的波动性会非常大，可以看到此时的拟合参数会异常大。通过L2正则化处理可以使这些参数变小，解释如下：

> 更小的权重，表示网络的复杂组更低，对数据拟合的刚刚好（奥卡姆剃须刀原理）



#### L1范数正则

L1正则假设参数的先验分布是Laplace分布，可以保证模型的稀疏性，也就是某些参数等于0；
L2正则假设参数的先验分布是Gaussian分布，可以保证模型的稳定性，也就是参数的值不会太大或太小

![两种正则化的对比](https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/359b033b5bb5c9ea238f2f6cdd39b6003bf3b3c4.jpg)
#### 参考链接
[lasso and ridge regularization](http://freemind.pluskid.org/machine-learning/sparsity-and-some-basics-of-l1-regularization/#ed61992b37932e208ae114be75e42a3e6dc34cb3)

### 交叉验证

就是将整个数据集切分成三个部分，分别是训练集、验证集和测试集。训练集用来训练模型，验证集用于模型 的选择，而测试集用于对学习方法的评估。

但是一般情况下，训练数据是不足的，那么此时可以重复的利用数据，进行反复训练以得到最优模型。

常见的方法有：
- S折交叉验证（S-fold cross validation）
- 留一交叉验证（S=N，当S为数据集的容量时，S折交叉验证就变成了留一交叉验证）



## 极大似然估计
最大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”

> 举个别人博客中的例子，假如有一个罐子，里面有黑白两种颜色的球，数目多少不知，两种颜色的比例也不知。我 们想知道罐中白球和黑球的比例，但我们不能把罐中的球全部拿出来数。现在我们可以每次任意从已经摇匀的罐中拿一个球出来，记录球的颜色，然后把拿出来的球 再放回罐中。这个过程可以重复，我们可以用记录的球的颜色来估计罐中黑白球的比例。假如在前面的一百次重复记录中，有七十次是白球，请问罐中白球所占的比例最有可能是多少？很多人马上就有答案了：70%。而其后的理论支撑是什么呢？

我们假设罐中白球的比例是$p$，那么黑球的比例就是$1-p$。因为每抽一个球出来，在记录颜色之后，我们把抽出的球放回了罐中并摇匀，所以每次抽出来的球的颜 色服从同一独立分布。这里我们把一次抽出来球的颜色称为一次抽样。题目中在一百次抽样中，七十次是白球的概率$P(Data|M)$，这里Data是所有的数据，M是所给出的模型，表示每次抽出来的球是白色的概率为$p$。如果第一抽样的结果记为`$x_1$`，第二抽样的结果记为`$x_2$`... 那么`$Data = (x_1,x_2,...,x_{100})$`。这样，
$$
P(Data|M)= P(x_1,x_2,...,x_{100}|M)= P(x_1|M)P(x_2|M)...P(x_{100}|M)= p^{70}(1-p)^{30}
$$
那么p在取什么值的时候，$P(Data|M)$的值最大呢？将$p^{70}(1-p)^{30}$对$p$求导，并其等于零。
$$
70p^{69}(1-p)^{30}-p^{70}*30(1-p)^{29}=0
$$

解方程可以得到`$p=0.7$`。
　　　　
  
  
### 最大熵原理

最大熵原理使概率学习中的一个准则。学习概率模型时，在所有的可能概率模型（分布）中，熵最大的模型是最好的模型。最大熵原理也可以理解成在满足约束条件的模型中选择熵最大的模型！

$$
H(p)=-\sum_x{log(P(x))P(x)}

$$
其中$X$服从的概率分布为$P(X)$，$X$服从均匀分布时，熵最大。当没有其他已知的约束时，$\Sigma{P(x)}=1$，此时按照最大熵原理，当$P(x_1)=P(x_2)=...=P(x_n)$时，熵最大；此时等概论，等概论意味着对事实的无知，因为没有更多可能的信息，所以此时的判断也是合情合理的。



### 线性分类器

线性分类器有三大类：感知器准则函数、$SVM$、$Fisher$准则，而贝叶斯分类器不是线性分类器。
- 感知器准则函数：代价函数$J=-(W*X+w_0)$，分类的准则是最小化代价函数。感知器是神经网络（$NN$）的基础，网上有很多介绍。
- $SVM$：支持向量机也是很经典的算法，优化目标是最大化间隔（margin），又称最大间隔分类器，是一种典型的线性分类器。（使用核函数可解决非线性问题）
- $Fisher$准则：更广泛的称呼是线性判别分析（$LDA$），将所有样本投影到一条远点出发的直线，使得同类样本距离尽可能小，不同类样本距离尽可能大，具体为最大化“广义瑞利商”。


### 评价指标



- 召回率就是有多少正确的被你找回来了；准确率就是你找到的有多少是正确的；(一般情况下召回率和准确率呈负相关，所以可以用F值衡量整体效果)
- TP(True Positive)是你判断为正确的，实际就是正确的；
- FP(False Positive)是你判断是错误的，实际也是错误的；
- TN(True Negative)是你判断为正确的，但实际是错误的；
- FN(False Negative)是你判断是错误的，但实际是正确的；



## 朴素贝叶斯 `$Naive Bayes$`

### 基本方法
朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的分类方法。NB的核心在于它假设向量的所有分量之间是独立的。在贝叶斯理论系统中，都有一个重要的条件独立性假设：假设所有特征之间相互独立，这样才能将联合概率拆分。
对于由$P(X,Y)$独立产生的训练集$T=\{(x_1,y_1),(x_2,y_2),..., (x_N,y_N),\}$而言通过朴素贝叶斯的方法学习这个联合概率分布。大致分两步：

1. 计算先验分布：
$$
P(Y=c_k),k=1,2...,K
$$
2. 条件概率分布：
$$
P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},X^{(2)}=x^{(2)},...,X^{(n)}=x^{(n)}|Y=c_k),k=1,2...,K
$$
其中的$x \in  R^{n}$，$n$表示这个样本的维度。
 
但是在计算条件概率时因为朴素贝叶斯做了条件独立性假设，那么该条件概率分布可以写成：

$$
P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},X^{(2)}=x^{(2)},...,X^{(n)}=x^{(n)}|Y=c_k)
\\
=\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)
$$

在实际分类时，对于给定的输入x，通过学习到的模型估计后验概率$P(Y=c_k|X=x)$将后验概率最大的类作为x的类的输出。
$$
P(Y=c_k|X=x)=\frac{P(X=x|Y=c_k)P(Y=c_k)}{\sum_{k}P(X=x|Y=c_k)P(Y=c_k)}\
=\frac{P(Y=c_k)\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)}{\sum_{k}P(Y=c_k)\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)}
$$
因为分母就是$P(X=x)$的概率，这是不变的。因此我们仅需要知道分子哪个大就可以，也就是：
$$
y={argmax}_{c_k} P(Y=c_k)\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)
$$
上式的意思是求解到底是哪些类别`$c_k$`能够让最大后验概率最大化。


### 参数估计

#### 极大似然估计

1. 计算先验概率
$$
P(Y=c_k)=\frac{\sum_{i=1}^NI(y_i=c_k)}{N}
$$

2. 计算条件概率
$$
P(X=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^NI(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^NI(y_i=c_k)}
$$
其中
$$
j=1,2...n;l=1,2...S_j;k=1,2...K
$$
3. 对于给定的实例x，计算
$$
P(Y=c_k)\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)
$$

4. 确定实例的类别